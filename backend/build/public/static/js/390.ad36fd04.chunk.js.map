{"version":3,"file":"static/js/390.ad36fd04.chunk.js","mappings":"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","sources":["components/game/components/board/index.tsx","components/game/components/wrapper/index.tsx","components/game/components/header/components/wrapper/index.tsx","components/game/components/header/components/players/index.tsx","components/game/components/header/components/score/index.tsx","components/game/components/header/components/countdown/index.tsx","components/game/components/header/index.tsx","components/game/components/header/helpers.ts","components/game/components/dices/components/wrapper/index.tsx","components/game/components/dices/components/button/index.tsx","components/game/components/dices/helpers.tsx","components/game/components/dices/index.tsx","components/game/components/buttons/index.tsx","components/game/components/score/components/value/index.tsx","components/game/components/score/index.tsx","components/game/components/messages/index.tsx","components/game/helpers.ts","components/game/index.tsx"],"sourcesContent":["import React from \"react\";\r\nimport { IBoard, IBoardItem, Player, TotalPlayers, TypeGame } from \"../../../../interfaces\";\r\nimport { ETypeGame } from \"../../../../utils/constants\";\r\nimport { BoardWrapper, BoardHeader, BoardTable} from \"./components\";\r\n\r\ninterface BoardProps {\r\n    items: IBoard;\r\n    players: Player[];\r\n    thrownDice?: boolean;\r\n    turn?: TotalPlayers;\r\n    typeGame?: TypeGame;\r\n    handleClick: (item: IBoardItem, player: TotalPlayers) => void;\r\n  }\r\n\r\n  const Board = (props: BoardProps) => (\r\n    <BoardWrapper>\r\n      <BoardHeader typeGame={props.typeGame as TypeGame} />\r\n      <BoardTable {...props} />\r\n    </BoardWrapper>\r\n  );\r\n\r\nexport default React.memo(Board);","import \"./styles.css\";\r\nimport React, { ReactNode } from \"react\";\r\n\r\nconst GameWrapper = ({\r\n  blockContent = false,\r\n  children,\r\n}: {\r\n  blockContent?: boolean;\r\n  children: JSX.Element | JSX.Element[] | ReactNode;\r\n}) => (\r\n  <div className=\"game-wrapper\">\r\n    {blockContent && <div className=\"game-wrapper-block-content\" />}\r\n    {children}\r\n  </div>\r\n);\r\n\r\nexport default React.memo(GameWrapper);","import \"./styles.css\";\r\nimport React from \"react\";\r\n\r\ninterface HeaderWrapperProps {\r\n  children: JSX.Element | JSX.Element[];\r\n}\r\n\r\nconst HeaderWrapper = ({ children }: HeaderWrapperProps) => (\r\n  <div className=\"header-wrapper\">{children}</div>\r\n);\r\n\r\nexport default React.memo(HeaderWrapper);","import \"./styles.css\";\r\nimport React from \"react\";\r\nimport type { HeaderCountdown, Player, TotalPlayers } from \"../../../../../../interfaces\";\r\nimport { ScoreHeader } from \"..\";\r\n\r\ninterface PlayersHeaderProps {\r\n    countdown?: HeaderCountdown;\r\n    players: Player[];\r\n    turn: TotalPlayers;\r\n  }\r\n\r\nconst PlayersHeader = ({countdown, players, turn = 1}: PlayersHeaderProps) => {\r\n    return (\r\n        <div className=\"header-players\">\r\n            {players.map((player, index) => {\r\n                return <ScoreHeader \r\n                countdown={countdown}\r\n                key={player.id} \r\n                isSelected={turn === index + 1} \r\n                player={player}\r\n                turn={turn}/>\r\n            })}\r\n        </div>\r\n    );\r\n};\r\n\r\nexport default React.memo(PlayersHeader);","import \"./styles.css\";\r\nimport React from \"react\";\r\nimport { HeaderCountdown, Player, TotalPlayers } from \"../../../../../../interfaces\";\r\nimport { Countdown } from \"..\";\r\nimport ScoreCounter from \"../../../scoreCounter\";\r\n\r\ninterface ScoreHeaderProps {\r\n    countdown?: HeaderCountdown;\r\n    isSelected?: boolean;\r\n    player: Player;\r\n    turn?: TotalPlayers;\r\n  }\r\n\r\nconst ScoreHeader = ({countdown, isSelected = false, player: {name, score}, turn = 1}: ScoreHeaderProps) => {\r\n    return (\r\n        <div className=\"header-players-item\">\r\n            <ScoreCounter \r\n            score={score}\r\n            className={`header-players-item-score ${isSelected ? \"selected\" : \"\"}`} />\r\n            <div className=\"header-players-item-name\">{name}</div>\r\n            {isSelected && countdown && (\r\n                <div className=\"header-players-item-countdown\">\r\n                    <Countdown \r\n                    stopCounter={countdown.stop} \r\n                    handleEndCountdown={() => countdown.onEndCountdown(turn)}\r\n                    />\r\n                </div>)}\r\n        </div>\r\n    );\r\n};\r\n\r\nexport default React.memo(ScoreHeader);","import \"./styles.css\";\r\nimport React, { useEffect, useState } from \"react\";\r\nimport { INTERVAL_TIME, INTERVAL_VALUE_COUNTDOWN } from \"../../../../../../utils/constants\";\r\nimport { useInterval } from \"../../../../../../hooks\";\r\n\r\ninterface CountdownProps {\r\n    initialValue?: number;\r\n    intervalTime?: number;\r\n    stopCounter?: boolean;\r\n    handleEndCountdown: () => void;\r\n  }\r\n\r\nconst Countdown = ({\r\n    initialValue = INTERVAL_VALUE_COUNTDOWN,\r\n    intervalTime = INTERVAL_TIME,\r\n    stopCounter = false,\r\n    handleEndCountdown,\r\n  }: CountdownProps) => {\r\n    const [count, setCount] = useState(initialValue);\r\n    const [isRunning, setIsRunning] = useState(true);\r\n\r\n    useEffect(() => setIsRunning(!stopCounter), [stopCounter]);\r\n\r\n    useInterval(\r\n        () => {\r\n        const newCount = count - 1;\r\n        if (newCount >= 0) {\r\n            setCount(newCount);\r\n        }\r\n\r\n        if (newCount === 0) {\r\n            setIsRunning(false);\r\n            handleEndCountdown();\r\n        }\r\n        },\r\n        isRunning ? intervalTime : null\r\n    );\r\n        return (\r\n            <div className={`header-players-countdown ${count <= 10 ? \"end-time\" : \"\"}`}>\r\n                {`${count <= 9 ? `0${count}` : count}`}    \r\n            </div>\r\n        );\r\n    };\r\n\r\nexport default React.memo(Countdown);","import React from \"react\";\r\nimport { HeaderWrapper, PlayersHeader } from \"./components\";\r\nimport CircularButton from \"../../../circularButton\";\r\nimport type { HeaderCountdown, Player, TotalPlayers } from \"../../../../interfaces\";\r\nimport { handleBack } from \"./helpers\";\r\nimport { useNavigate } from \"react-router-dom\";\r\nimport { useSounds } from \"../../../../hooks\";\r\n\r\ninterface HeaderProps {\r\n    countdown?: HeaderCountdown;\r\n    players: Player[];\r\n    turn: TotalPlayers;\r\n  }\r\n\r\nconst Header = (props: HeaderProps) => {\r\n\r\n    const {withSound, toggleSound} = useSounds();\r\n    const navigate = useNavigate();\r\n\r\n    return (\r\n        <HeaderWrapper>\r\n            <CircularButton type=\"back\" onClick={() => {\r\n                handleBack((action) => action && navigate(\"/\"));\r\n            }}></CircularButton>\r\n            <PlayersHeader {...props}/>\r\n            <CircularButton \r\n                type={withSound ? \"sound-on\" : \"sound-off\"}\r\n                onClick={toggleSound}></CircularButton>\r\n        </HeaderWrapper>\r\n    );\r\n};\r\n\r\nexport default React.memo(Header);","import swal from \"sweetalert\";\r\n\r\nexport const handleBack = (cb: (action: boolean) => void) => {\r\n  swal({\r\n    title: \"Saliendo\",\r\n    text: \"¿Seguro que quieres salir del juego?\",\r\n    icon: \"warning\",\r\n    closeOnClickOutside: false,\r\n    closeOnEsc: false,\r\n    buttons: [\"NO\", \"SI\"],\r\n  }).then((value) => cb(!!value));\r\n};","import \"./styles.css\";\r\nimport React from \"react\";\r\n\r\nconst DiceWrapper = ({\r\n  children,\r\n}: {\r\n  children: JSX.Element | JSX.Element[];\r\n}) => <div className=\"dices-wrapper\">{children}</div>;\r\n\r\nexport default React.memo(DiceWrapper);","import \"./styles.css\";\r\nimport React, { useEffect, useRef } from \"react\";\r\nimport { DiceState, DiceTheme, DiceValue } from \"../../../../../../interfaces\";\r\nimport { EDiceState, EDiceTheme } from \"../../../../../../utils/constants\";\r\nimport ReactDice, { ReactDiceRef } from \"react-dice-complete\";\r\n\r\ninterface DiceButtonProps {\r\n    dice: DiceValue;\r\n    dieState: DiceState;\r\n    diceTheme: DiceTheme;\r\n    handleDone: () => void;\r\n    handleSelectedDice: (index: number) => void;\r\n}\r\n\r\ntype Theme = { [key in DiceTheme]: { dotColor: string; faceColor: string } };\r\n\r\nconst theme: Theme = {\r\n  WHITE: {\r\n    dotColor: \"black\",\r\n    faceColor: \"white\",\r\n  },\r\n  RED: {\r\n    dotColor: \"white\",\r\n    faceColor: \"red\",\r\n  },\r\n};\r\n\r\nconst DiceButton = ({\r\n    dice = {index: 0, value: 0, selected: false},\r\n    dieState = EDiceState.HIDE,\r\n    diceTheme = EDiceTheme.WHITE,\r\n    handleDone,\r\n    handleSelectedDice,\r\n}: DiceButtonProps) => {\r\n\r\n    // Guarda la referencia del dado para poder usar la función de tipo rollAll\r\n  // https://www.npmjs.com/package/react-dice-complete\r\n    const refDice = useRef<ReactDiceRef>(null);\r\n\r\n     // Determina la velocidad de gira de cada dado\r\n     // Para que cada dado tenga un tiempo distinto de giro y por ende tengan valores distintos\r\n    const rollTime =\r\n    dieState === EDiceState.SPIN && !dice.selected\r\n    ? 0.5 + dice.index * 0.15\r\n    : 0;\r\n\r\n    // Accecibilidad para el titulo del boton\r\n    const title = \r\n    `Dice ${dice.index + 1}` + \r\n    (dieState === EDiceState.STOPPED ? ` = ${dice.value}` : \"\");\r\n\r\n    // Asocia la clase de selección del dado\r\n    // Además de la clase para ocultarlo...\r\n    const className = `dices-button ${dice.selected ? \"selected\" : \"\"} ${\r\n        dieState === EDiceState.HIDE ? \"hide\" : \"\"\r\n      }`;    \r\n\r\n    /**\r\n    * Bloquea el botón si el dado está oculto o si está rotanto\r\n    * O si el tema es rojo indicando que es otro jugador...\r\n    */\r\n    const disabledButton =\r\n    !(dieState === EDiceState.STOPPED) || diceTheme === EDiceTheme.RED;\r\n\r\n\r\n    // Establece el color del dado\r\n    const { dotColor, faceColor } = theme[diceTheme];\r\n\r\n    /**\r\n    * Efecto que se ejecuta cuando el valor del dado ha cambiado...\r\n    */\r\n    useEffect(() => {\r\n    const { value, selected } = dice;\r\n\r\n    // Establece si debe girar el dado, en este caso con el valor de value\r\n    // pero si está seleccionado no hará ninguna acción...\r\n    if (value !== 0 && !selected) {\r\n      refDice.current?.rollAll([value]);\r\n    }\r\n  }, [refDice, dice]);\r\n\r\n    return (\r\n        <button \r\n            className={className} \r\n            onClick={() => handleSelectedDice(dice.index)}\r\n            disabled={disabledButton}\r\n            title={title}\r\n            >\r\n            <ReactDice \r\n                dieSize={52}\r\n                disableIndividual\r\n                numDice={1} \r\n                dotColor={dotColor}\r\n                faceColor={faceColor}\r\n                outlineColor=\"white\"\r\n                ref={refDice}\r\n                rollDone={handleDone}\r\n                rollTime={rollTime}\r\n                />\r\n        </button>\r\n    );\r\n};\r\n\r\nexport default React.memo(DiceButton);","import type { DiceValue } from \"../../../../interfaces\";\r\n\r\n// Debido a que es una acción que no cambia nada en el render del componete\r\n// es posible usar una variable global y no mantenerla en un estado\r\nlet counterRollingDice: number[] = [];\r\n\r\n/**\r\n * Función que valida que todos los dados que no estén seleccionados,\r\n * hayan terminado de girar\r\n * @param value\r\n * @param values\r\n * @param handleDoneDices\r\n */\r\nexport const handleAllDiceComplete = (\r\n  value: number,\r\n  values: DiceValue[],\r\n  handleDoneDices: () => void\r\n) => {\r\n  // Se valida que el valor del dado que ha terminado no este en el array\r\n  if (!counterRollingDice.includes(value)) {\r\n    counterRollingDice.push(value);\r\n\r\n    // Se extrae el total de dados que no están seleccionados\r\n    // y de esta forma se obtiene el total de dados que se deben validar\r\n    const totalStopDice = values.filter((v) => !v.selected).length;\r\n\r\n    // Se valida que ya hayan terminado de girar todos los dados requeridos...\r\n    if (totalStopDice !== 0 && counterRollingDice.length === totalStopDice) {\r\n      // Se limpia la variable global\r\n      counterRollingDice = [];\r\n      // Se indica al componente padre que los dados han terminado de girar...\r\n      handleDoneDices();\r\n    }\r\n  }\r\n};","import React from \"react\";\r\nimport { DiceButton, DiceWrapper } from \"./components\";\r\nimport { DiceState, DiceTheme, DiceValue } from \"../../../../interfaces\";\r\nimport { EDiceState, EDiceTheme } from \"../../../../utils/constants\";\r\nimport { handleAllDiceComplete } from \"./helpers\";\r\n\r\ninterface DicesProps {\r\n    values: DiceValue[];\r\n    dieState: DiceState;\r\n    diceTheme: DiceTheme;\r\n    handleDoneDices: () => void;\r\n    handleSelectedDice: (index: number) => void;\r\n}\r\n\r\nconst Dices = ({\r\n    values = [], \r\n    diceTheme = EDiceTheme.WHITE, \r\n    dieState = EDiceState.HIDE, \r\n    handleDoneDices,\r\n    handleSelectedDice,\r\n}: DicesProps) => {\r\n    return (\r\n        <DiceWrapper>\r\n            {values.map((value) => {\r\n                return ( \r\n                    <DiceButton \r\n                    dice={value} \r\n                    diceTheme={diceTheme}\r\n                    dieState={dieState} \r\n                    handleSelectedDice={handleSelectedDice}\r\n                    key={`dice-${value.index}`}\r\n                    handleDone={() => {\r\n                        if(dieState === EDiceState.SPIN){\r\n                            handleAllDiceComplete(value.index + 1, values, handleDoneDices);\r\n                        }\r\n                    }}\r\n                    />)\r\n            })}\r\n        </DiceWrapper>\r\n    );\r\n};\r\n\r\nexport default React.memo(Dices);","import \"./styles.css\";\r\nimport React from \"react\";\r\nimport { ETypeButtonGame, LABELS_GAME, TOTAL_THROWING } from \"../../../../utils/constants\";\r\nimport { TypeButtonGame } from \"../../../../interfaces\";\r\n\r\ninterface ButtonsProps {\r\n    disabledPlay: boolean;\r\n    disabledRoll: boolean;\r\n    showPlay: boolean;\r\n    throwing: number;\r\n    handleClick: (type: TypeButtonGame) => void;\r\n}\r\n\r\nconst Buttons = ({\r\n    disabledPlay = false,\r\n    disabledRoll = false,\r\n    showPlay = false,\r\n    throwing = TOTAL_THROWING,\r\n    handleClick,\r\n}: ButtonsProps) => {\r\n    return (\r\n    <div className=\"game-buttons\">\r\n        <button className=\"button game-buttons-roll\"\r\n        disabled={disabledRoll}\r\n        onClick={() => handleClick(ETypeButtonGame.ROLL)} \r\n        >\r\n            {LABELS_GAME.ROLL}\r\n            <span>{throwing}</span>\r\n            </button>\r\n            {showPlay && (\r\n                <button \r\n                className=\"button orange\" \r\n                disabled={disabledPlay}\r\n                onClick={() => handleClick(ETypeButtonGame.PLAY)}\r\n                >\r\n                    {LABELS_GAME.PLAY}\r\n                </button>\r\n            )}\r\n    </div>\r\n);\r\n};\r\n\r\nexport default React.memo(Buttons);","import \"./styles.css\";\r\nimport React from \"react\";\r\nimport ScoreCounter from \"../../../scoreCounter\";\r\n\r\ninterface ScoreValueProps {\r\n    index: number;\r\n    score: number;\r\n    name?: string;\r\n    handleShowScore: () => void;\r\n  }\r\n  \r\n  const ScoreValue = ({\r\n    index = 0,\r\n    score = 0,\r\n    name = \"\",\r\n    handleShowScore,\r\n  }: ScoreValueProps) => (\r\n    <div className={`score-game-value-item item-${index}`}>\r\n      <ScoreCounter\r\n        className=\"score-game-value-value\"\r\n        index={index}\r\n        intervalTime={10}\r\n        score={score}\r\n        handleEndTimer={handleShowScore}\r\n      />\r\n      {name && <div className=\"score-game-value-name\">{name}</div>}\r\n    </div>\r\n  );\r\n\r\nexport default React.memo(ScoreValue);","import \"./styles.css\";\r\nimport React, { useEffect, useState } from \"react\";\r\nimport type { Player } from \"../../../../interfaces\";\r\nimport CircularButton from \"../../../circularButton\";\r\nimport { ScoreValue } from \"./components\";\r\nimport { LABELS_GAME } from \"../../../../utils/constants\";\r\nimport Icon from \"../icon\";\r\nimport FocusTrap from \"focus-trap-react\";\r\nimport Share from \"../../../share\";\r\nimport { useNavigate } from \"react-router-dom\";\r\n\r\ninterface ScoreGameProps {\r\n    players: Player[];\r\n  }\r\n  \r\n  const ScoreGame = ({ players }: ScoreGameProps) => {\r\n    const navigate = useNavigate();\r\n    const [scoreCounter, setScoreCounter] = useState(0);\r\n    const [showElements, setShowElements] = useState(false);\r\n  \r\n    /**\r\n     * Efecto que se ejecuta cuando el número del contador del score cambia\r\n     * En este caso se compara con el total de jugadores\r\n     * cuando es igual, quiere decir que el conteo ha terminado y muestra los demás\r\n     * elementos del UI\r\n     */\r\n    useEffect(\r\n      () => setShowElements(scoreCounter === players.length),\r\n      [scoreCounter, players]\r\n    );\r\n  \r\n    const scoreMessage =\r\n      players.length === 1\r\n        ? LABELS_GAME.AMAZING_SCORE\r\n        : players[0].score === players[1].score\r\n        ? LABELS_GAME.TIE\r\n        : players[0].score > players[1].score\r\n        ? LABELS_GAME.WON\r\n        : LABELS_GAME.LOSE;\r\n  \r\n    /**\r\n     * Para el mensaje que se comparte en la opción share...\r\n     */\r\n    const dataShare = {\r\n      title: \"React Dices\",\r\n      text: `Obtuve este puntaje ${players[0].score} en React Dices!.`,\r\n      url: window.location.origin,\r\n    };\r\n  \r\n    /**\r\n     * Se agrega FocusTrap para evitar que se navegue con el teclado\r\n     * cuando se muestra el modal del score\r\n     */\r\n    return (\r\n      <FocusTrap>\r\n        <div className=\"score-game\">\r\n          <div className={`score-game-wrapper ${showElements ? \"show\" : \"\"}`}>\r\n            {/* Se deja visible por defecto un botón, para que tenga el focus */}\r\n            <CircularButton onClick={() => navigate(\"/\")} />\r\n            <div className=\"score-game-value\">\r\n              {players.map(({ id, score, name }, key) => (\r\n                <ScoreValue\r\n                  index={key + 1}\r\n                  key={id}\r\n                  name={players.length === 2 ? name : \"\"}\r\n                  score={score}\r\n                  handleShowScore={() => setScoreCounter((value) => value + 1)}\r\n                />\r\n              ))}\r\n            </div>\r\n            <div className=\"score-game-message\">{scoreMessage}</div>\r\n            <div className=\"score-game-buttons\">\r\n              <button\r\n                className=\"button orange score-game-buttons-play\"\r\n                onClick={() => navigate(\"/\")}\r\n              >\r\n                Play Again\r\n              </button>\r\n              <div className=\"score-game-buttons-bottom\">\r\n                <button title=\"Return to lobby\" onClick={() => navigate(\"/\")}>\r\n                  <Icon type=\"full-house\" fill=\"white\" />\r\n                </button>\r\n                <Share data={dataShare}>\r\n                  <button title=\"Share\">\r\n                    <Icon type=\"share\" fill=\"white\" />\r\n                  </button>\r\n                  </Share>\r\n              </div>\r\n            </div>\r\n          </div>\r\n        </div>\r\n      </FocusTrap>\r\n    );\r\n  };\r\n\r\nexport default React.memo(ScoreGame);","import \"./styles.css\";\r\nimport React, { useEffect, useState } from \"react\";\r\n\r\ninterface GameMessagesProps {\r\n  isYatzy: boolean;\r\n  value: string;\r\n  counter: number;\r\n}\r\n\r\nconst GameMessages = ({\r\n  isYatzy = false,\r\n  value = \"\",\r\n  counter = 0,\r\n}: GameMessagesProps) => {\r\n  const [showMessage, setShowMessage] = useState(false);\r\n\r\n  useEffect(() => {\r\n    let interval: ReturnType<typeof setTimeout>;\r\n\r\n    if (counter !== 0) {\r\n      setShowMessage(true);\r\n\r\n      interval = setTimeout(() => {\r\n        setShowMessage(false);\r\n      }, 1500);\r\n    }\r\n\r\n    return () => {\r\n      if (interval) {\r\n        clearTimeout(interval);\r\n      }\r\n    };\r\n  }, [counter]);\r\n\r\n  const className = !isYatzy\r\n    ? \"game-messages-wrapper\"\r\n    : \"game-messages-wrapper-yatzy\";\r\n\r\n  return (\r\n    <div className={`game-messages ${showMessage ? \"show\" : \"hide\"}`}>\r\n      <div className={className}>{value}</div>\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default React.memo(GameMessages);","import { CategoriesType, DiceValue, Difficulty, IBoard, IBoardItem, IScore, IscoreBoard, ItemSelectedBoard, ItemType, Player, TotalPlayers, TypeGame, valueDice } from \"../../interfaces\";\r\nimport { BONUS_VALUE, CATEGORIES, EDifficulty, EItemType, ETypeGame, INITIAL_ITEM_SELECTED, LABELS_GAME, LOWER_SECTION_LABELS, MIN_SCORE_BONUS, TOTAL_THROWING, UPPER_SECTION_LABELS, YATZY_SCORES } from \"../../utils/constants\";\r\nimport cloneDeep from \"lodash.clonedeep\";\r\nimport { randomNumber } from \"../../utils/helpers\";\r\n\r\n\r\n/**\r\n * Dado el valor de un dado, devuelve la cantidad total de dados con el mismo valor...\r\n * @param value\r\n * @param diceValues\r\n * @returns\r\n */\r\nconst totalDiceSameValue = (value: valueDice, diceValues: DiceValue[]) =>\r\n  diceValues.filter((v) => v.value === value).length;\r\n\r\n /**\r\n  * Retorna la sumatoria de todos los dados.\r\n  * @param value\r\n  * @param diceValues\r\n  * @returns\r\n */\r\n  const calculateSumDiceSameValue = (value: valueDice, diceValues: DiceValue[]) =>\r\n    totalDiceSameValue(value, diceValues) * value;\r\n\r\n/**\r\n * Retorna la sumatoria de todos los dados.\r\n * @param diceValues\r\n * @returns\r\n */\r\nconst calculateSumAllDice = (diceValues: DiceValue[]) =>\r\n  diceValues.reduce((a, s) => a + s.value, 0);\r\n\r\n/**\r\n * Valida si existen dados con el mismo valor, en este caso con el número de repeticiones\r\n * exactValue valida si el número de ocurrencias debe ser exacto o puede ser mayor, este\r\n * valor es útil para validar full house y los valores repetido\r\n * @param repetitions\r\n * @param diceValues\r\n * @param exactValue\r\n * @returns\r\n */\r\nconst calculateDiceSameType = (\r\n  repetitions: number = 2,\r\n  diceValues: DiceValue[],\r\n  exactValue: boolean = false\r\n) => {\r\n  let isRepetition = false;\r\n\r\n  for (let i = 1; i <= 6; i++) {\r\n    const total = totalDiceSameValue(i as valueDice, diceValues);\r\n\r\n    isRepetition = exactValue ? total === repetitions : total >= repetitions;\r\n\r\n    if (isRepetition) {\r\n      break;\r\n    }\r\n  }\r\n\r\n  return isRepetition;\r\n};\r\n\r\n\r\nconst calculateIsStraight = (diceValues: DiceValue[], straight: 4 | 5 = 4) => {\r\n  let isStraight = false;\r\n\r\n  /**\r\n   * Se clona el valor de los dados\r\n   * Se extrae sólo el valor del dado\r\n   * Se ordenan los valores\r\n   * Se elimina  los valores repetidos...\r\n   */\r\n  const copyDiceValues = [\r\n    ...new Set(\r\n      cloneDeep(diceValues)\r\n        .map((v) => v.value as number)\r\n        .sort((a, b) => a - b)\r\n    ),\r\n  ];\r\n\r\n  /**\r\n   * El valor inicial que se pregunta del straight\r\n   */\r\n\r\n  let initial = 1;\r\n\r\n  do {\r\n    if (initial + (straight - 1) <= 6) {\r\n      let counterStraight = 0;\r\n\r\n      // Se itera el número de veces que se desea validar un straight\r\n      // Si el valor del dado es el mismo que el contador se aumenta...\r\n      for (let i = 0; i < straight; i++) {\r\n        // Se valida que exista en el valor en el vector.\r\n        // Si es así se sumará\r\n        // No existe peligro de repetición, ya que sólo exiten valores únicos...\r\n        counterStraight += copyDiceValues.includes(i + initial) ? 1 : 0;\r\n      }\r\n\r\n      isStraight = counterStraight === straight;\r\n      initial++;\r\n\r\n      if (isStraight) {\r\n        break;\r\n      }\r\n    } else {\r\n      break;\r\n    }\r\n  } while (1);\r\n\r\n  return isStraight;\r\n};\r\n\r\n/**\r\n * Calcula el score para cada sección del board\r\n * @param section\r\n * @param turn\r\n * @returns\r\n*/\r\n  const calculateScoreSections = (section: IBoardItem[], turn: TotalPlayers) =>\r\n  section.reduce((a, s) => a + s.score[turn - 1].value, 0);\r\n\r\n  /**\r\n * En este caso revisa el array de score\r\n * el valor isUsed debe ser true en todos los scores (tanto para un juagdor como para dos)\r\n * @param boardState\r\n * @param typeGame\r\n */\r\nconst validateGameOver = (boardState: IBoard, typeGame: TypeGame) => {\r\n  // Si el tipo de juego es sólo, en este caso sólo se valida el primer score\r\n  const scoreSize = typeGame === ETypeGame.SOLO ? 1 : 2;\r\n\r\n  const completeBoard = Object.keys(EItemType).map((type) => {\r\n    const section = boardState[type as ItemType];\r\n    // Se obtiene el total de score de cada\r\n    // item (UPPER_SECTION = 6, LOWER_SECTION = 7)\r\n    const size = section.length;\r\n    let total = 0;\r\n\r\n    for (let i = 0; i < size; i++) {\r\n      let totalSize = 0;\r\n\r\n      // El scoreSize será 1 cuando es sólo y dos para los demás\r\n      for (let c = 0; c < scoreSize; c++) {\r\n        totalSize += section[i].score[c].isUsed ? 1 : 0;\r\n      }\r\n\r\n      total += totalSize === scoreSize ? 1 : 0;\r\n    }\r\n\r\n    // Si el total global es igual al tamaño de la sección\r\n    // quiere decir que todos tienen un score asociado\r\n    return total === size;\r\n  });\r\n\r\n  // Los valores de las dos secciones deben ser true\r\n  // de esta forma se ha seleccionado todos los valores\r\n  return completeBoard.every((v) => v);\r\n};\r\n\r\n/**\r\n * Función que devuelve uan lista de indices para selección\r\n * aleatoria de dados, de forma única...\r\n * @param total\r\n * @returns\r\n */\r\nconst getSelectionRandomDice = (total: number = 1) => {\r\n  const selectedDice: number[] = [];\r\n\r\n  // Ciclo infinito que intera por la cantida dada en total...\r\n  // el ciclo se rompera una vez el tamaño de selectedDice sea igual que total\r\n  do {\r\n    // Generar el valor del dado...\r\n    // se hace de 0 hasta 4, en este caso para los cinco dados...\r\n    // los valores obtenidos son los indices de cada dado...\r\n    const randomDice = randomNumber(0, 4);\r\n\r\n    // Se valida que no exista ya el valor del dado en el vector de selección.\r\n    if (!selectedDice.includes(randomDice)) {\r\n      // Si no existe, se adiciona\r\n      selectedDice.push(randomDice);\r\n    }\r\n\r\n    // Si el tamaño del vector es igual al total a generar\r\n    // Se rompe el cliclo...\r\n    if (selectedDice.length === total) {\r\n      break;\r\n    }\r\n  } while (1);\r\n\r\n  return selectedDice;\r\n};\r\n\r\n/**\r\n * Función que retorna el mayor o menor valor de una sección\r\n * Depende del nivel de dificultad solicitado\r\n * Devuelve el primero en cada caso...\r\n * @param section\r\n * @param turn\r\n * @param difficulty\r\n * @returns\r\n */\r\nconst getScoreSectionBot = (\r\n  section: IBoardItem[],\r\n  turn: TotalPlayers,\r\n  difficulty: Difficulty\r\n) => {\r\n  const scores = section\r\n    .filter((value) => !value.score[turn - 1].isUsed)\r\n    .map((value) => ({\r\n      index: value.index,\r\n      score: value.score[turn - 1].temporal,\r\n    }))\r\n    .sort((a, b) =>\r\n      difficulty === EDifficulty.HARD ? b.score - a.score : a.score - b.score\r\n    );\r\n\r\n  /**\r\n   * Se separan los scores que tengan valor de los que no\r\n   */\r\n  const scoreNoZero = scores.filter((v) => v.score !== 0);\r\n  const scoreZero = scores.filter((v) => v.score === 0);\r\n\r\n  /**\r\n   * Se da prioridad al score con valores...\r\n   */\r\n  return scoreNoZero?.[0] || scoreZero?.[0];\r\n};\r\n\r\n/**\r\n * Crea el estado inicial del board\r\n * @returns\r\n */\r\nexport const getInitalBoardState = () => {\r\n    // La base del score\r\n    const initialScore: IScore = {\r\n      value: 0,\r\n      temporal: 0,\r\n      isSelected: false,\r\n      isUsed: false,\r\n      isBonusYatzy: false,\r\n    };\r\n  \r\n    // Por defecto son 6 valores, correspondientes a cada dado...\r\n    const UPPER_SECTION: IBoardItem[] = new Array(6)\r\n      .fill(null)\r\n      .map((_, index) => {\r\n        const score: IscoreBoard = [initialScore, initialScore];\r\n  \r\n        return {\r\n          index,\r\n          label: UPPER_SECTION_LABELS[index],\r\n          score,\r\n          type: EItemType.UPPER_SECTION,\r\n          value: (index + 1) as valueDice,\r\n        };\r\n      });\r\n\r\n      // Son 7, correspondiente a la catagoria existente...\r\n    const LOWER_SECTION: IBoardItem[] = CATEGORIES.map((category, index) => {\r\n    const score: IscoreBoard = [initialScore, initialScore];\r\n\r\n    return {\r\n      index,\r\n      label: LOWER_SECTION_LABELS[index],\r\n      score,\r\n      type: EItemType.LOWER_SECTION,\r\n      value: category,\r\n    };\r\n    });\r\n\r\n    const INITIAL_BOARD_GAME: IBoard = { UPPER_SECTION, LOWER_SECTION };\r\n\r\n    return INITIAL_BOARD_GAME;\r\n\r\n\r\n};\r\n\r\n/**\r\n * Devuleve la información inicial de los players...\r\n * Si existe un player autenticado, pasará los datos de ese usuario\r\n * @param typeGame\r\n * @param authUser\r\n * @param opponent\r\n * @returns\r\n */\r\nexport const getInitialPlayers = (\r\n    typeGame: TypeGame = ETypeGame.SOLO,\r\n    authUser: Partial<Player> = {},\r\n    opponent: Partial<Player> = {}\r\n) => {\r\n    // Se determina la cantidad de jugadores dependiendo del tipo de juego\r\n    const totalPlayers: TotalPlayers = typeGame === ETypeGame.SOLO ? 1 : 2;\r\n\r\n    // Se establece la data base para un jugador...\r\n    const basePlayer: Player = {\r\n    id: \"\",\r\n    name: \"\",\r\n    score: 0,\r\n    scoreBoard: { UPPER_SECTION: 0, LOWER_SECTION: 0 },\r\n    isBonusEarned: false,\r\n    };\r\n\r\n    // Se genera el array de información para los jugadores...\r\n    // y se especifica la data faltante, como el nombre y el id\r\n    const players: Player[] = new Array(totalPlayers)\r\n    .fill(null)\r\n    .map((_, index) => ({\r\n        ...basePlayer,\r\n        id: `player${index + 1}`,\r\n        name: `Player ${index + 1}`,\r\n    }));\r\n\r\n    // Se establecen labels personalizados para los nombres...\r\n    if (typeGame === ETypeGame.SOLO || typeGame === ETypeGame.BOT) {\r\n        players[0].name = LABELS_GAME.YOU;\r\n    }\r\n\r\n    // En este caso para el bot...\r\n    if (typeGame === ETypeGame.BOT) {\r\n        players[1].name = LABELS_GAME.BOT;\r\n    }\r\n\r\n    // Si el usuario está autenticado, se establece sus datos...\r\n    // aplicable para el jugador 1\r\n    players[0] = { ...players[0], ...authUser };\r\n\r\n    // Para completar los datos del oponente,\r\n    // sólo cuando es la versión online\r\n    if (typeGame === ETypeGame.ONLINE && opponent) {\r\n        players[1] = { ...players[1], ...opponent };\r\n    }\r\n\r\n    return players;\r\n};\r\n\r\n/**\r\n * Genera los datos iniciales de los dados...\r\n */\r\nexport const getInitialDiceValues = () =>\r\n  new Array(5).fill(null).map(\r\n    (_, index) =>\r\n      ({\r\n        index,\r\n        value: 0,\r\n        selected: false,\r\n      } as DiceValue)\r\n  );\r\n\r\n\r\n  /**\r\n  * Función que genera los valores de los dados...\r\n  * @param diceValues\r\n  * @returns\r\n  */\r\n  export const rollDice = (diceValues: DiceValue[]) => {\r\n    const copyDiceValues = cloneDeep(diceValues);\r\n    // copyDiceValues[0].value = 2;\r\n    // copyDiceValues[1].value = 2;\r\n    // copyDiceValues[2].value = 2;\r\n    // copyDiceValues[3].value = 2;\r\n    // copyDiceValues[4].value = 2;\r\n\r\n    for (let i = 0; i < copyDiceValues.length; i++) {\r\n      if (!copyDiceValues[i].selected) {\r\n        copyDiceValues[i].value = randomNumber(1, 6) as valueDice;\r\n        // Validar Yatzy\r\n        // copyDiceValues[i].value = 5;\r\n      }\r\n    }\r\n\r\n    return copyDiceValues;\r\n  };\r\n\r\n  /**\r\n * Función que establece cuando un dado ha sido seleccioando...\r\n * @param diceValues\r\n * @param diceIndex\r\n * @returns\r\n */\r\nexport const selectDice = (diceValues: DiceValue[], diceIndex: number = 0) => {\r\n  const copyDiceValues = cloneDeep(diceValues);\r\n  copyDiceValues[diceIndex].selected = !copyDiceValues[diceIndex].selected;\r\n\r\n  return copyDiceValues;\r\n};\r\n\r\n/**\r\n * Devuelve la cantidad de dados que se pueden mover\r\n * útil para saber si el botón de roll estará habilitado\r\n * @param diceValues\r\n * @returns\r\n */\r\nexport const totalDiceAvailable = (diceValues: DiceValue[]) =>\r\n  diceValues.filter((v) => !v.selected).length;\r\n\r\n/**\r\n * Calcula los valores que serán mostrados en el board...\r\n * @param boardState\r\n * @param diceValues\r\n * @param turn\r\n * @returns\r\n */\r\nexport const calculateBoardValues = (\r\n  boardState: IBoard,\r\n  diceValues: DiceValue[],\r\n  turn: TotalPlayers = 1\r\n) => {\r\n\r\n  const copyBoardState: IBoard = JSON.parse(JSON.stringify(boardState));\r\n  \r\n   // Obtener la sumatoria de todos los dados...\r\n   const sumAllDice = calculateSumAllDice(diceValues);\r\n   const isThreeKind = calculateDiceSameType(3, diceValues);\r\n   const isFourKind = calculateDiceSameType(4, diceValues);\r\n\r\n    /**\r\n    * Valida si es el isFullHouse, en este caso debe hacer tres dados del mismo tipo\r\n    * y dos del mismo tipo, debe ser exacta la cantidad, por eso la bandera de exactValue\r\n    */\r\n   const isFullHouse =\r\n   calculateDiceSameType(3, diceValues, true) &&\r\n   calculateDiceSameType(2, diceValues, true);\r\n\r\n   const isSmallStraight = calculateIsStraight(diceValues, 4);\r\n   const isLargeStraight = calculateIsStraight(diceValues, 5);\r\n\r\n   /**\r\n   * Para ser un Yatzy todos los dados deben ser del mismo tipo...\r\n   */\r\n   const isYatzy = calculateDiceSameType(5, diceValues);\r\n\r\n   // console.log({\r\n  //   sumAllDice,\r\n  //   isThreeKind,\r\n  //   isFourKind,\r\n  //   isFullHouse,\r\n  //   isSmallStraight,\r\n  //   isLargeStraight,\r\n  //   isYatzy,\r\n  // });\r\n\r\n  /**\r\n   * Se establece el puntaje para sección baja de la tabla,\r\n   * de acuerdo a los valores obtenidos en las funciones de arriba...\r\n   */\r\n  const lowerSectionValues: { [key in CategoriesType]: number } = {\r\n    THREE_KIND: isThreeKind ? sumAllDice : 0,\r\n    FOUR_KIND: isFourKind ? sumAllDice : 0,\r\n    FULL_HOUSE: isFullHouse ? YATZY_SCORES.FULLHOUSE : 0,\r\n    SMALL_STRAIGHT: isSmallStraight ? YATZY_SCORES.SMALL_STRAIGHT : 0,\r\n    LARGE_STRAIGHT: isLargeStraight ? YATZY_SCORES.LARGE_STRAIGHT : 0,\r\n    YATZY: isYatzy ? YATZY_SCORES.YATZY : 0,\r\n    CHANCE: sumAllDice,\r\n  };\r\n\r\n  // console.log(lowerSectionValues);\r\n\r\n  /**\r\n   * Establecer los valores para para la seccción alta, en este caso\r\n   * son las sumatorias de los dados...\r\n   */\r\n  for (let i = 0; i < copyBoardState.UPPER_SECTION.length; i++) {\r\n    // Si no se ha usado la casilla, se establece el valor temporal para la misma\r\n    if (!copyBoardState.UPPER_SECTION[i].score[turn - 1]?.isUsed) {\r\n      const { value } = copyBoardState.UPPER_SECTION[i];\r\n      const totalValue = calculateSumDiceSameValue(\r\n        value as valueDice,\r\n        diceValues\r\n      );\r\n\r\n      copyBoardState.UPPER_SECTION[i].score[turn - 1].temporal = totalValue;\r\n    }\r\n  }\r\n\r\n  for (let i = 0; i < copyBoardState.LOWER_SECTION.length; i++) {\r\n    const { value } = copyBoardState.LOWER_SECTION[i];\r\n\r\n    // Si no está usado se podrá establecer su valor temporal\r\n    if (!copyBoardState.LOWER_SECTION[i].score[turn - 1]?.isUsed) {\r\n      copyBoardState.LOWER_SECTION[i].score[turn - 1].temporal =\r\n        lowerSectionValues[value as CategoriesType];\r\n    }\r\n  }\r\n\r\n  return { isYatzy, copyBoardState };\r\n\r\n};\r\n\r\n/**\r\n * Selecciona un ítem del board\r\n * @param boardState\r\n * @param itemSelected\r\n * @param item\r\n * @param turn\r\n * @param isYatzy\r\n * @returns\r\n */\r\nexport const selectItemBoard = (\r\n  boardState: IBoard,\r\n  itemSelected: ItemSelectedBoard,\r\n  item: IBoardItem,\r\n  turn: TotalPlayers,\r\n  isYatzy: boolean = false\r\n) => {\r\n  const copyBoardState: IBoard = cloneDeep(boardState);\r\n  const newItemSelected: ItemSelectedBoard = cloneDeep(INITIAL_ITEM_SELECTED);\r\n  const { isUsed } = copyBoardState[item.type][item.index].score[turn - 1];\r\n  // Establece si cambia o no el estado en el board\r\n  let changeState = false;\r\n\r\n  if (!isUsed) {\r\n    // Si ya se había seleccionado un ítem, lo deseleccionará\r\n    if (itemSelected.index >= 0) {\r\n      copyBoardState[itemSelected.type][itemSelected.index].score[\r\n        turn - 1\r\n      ].isSelected = false;\r\n\r\n      // Establece por defecto que el no hay bono de Yatzy\r\n      copyBoardState[itemSelected.type][itemSelected.index].score[\r\n        turn - 1\r\n      ].isBonusYatzy = false;\r\n    }\r\n\r\n    // Valida si el ítem ya estaba seleccionado\r\n    // es decir si seleccionó el mismo que había seleccionado antes\r\n    const alreadySelected =\r\n      itemSelected.index === item.index && itemSelected.type === item.type;\r\n\r\n    // Si no es el caso, se puede mutar el valor\r\n    if (!alreadySelected) {\r\n      newItemSelected.index = item.index;\r\n      newItemSelected.type = item.type;\r\n      copyBoardState[item.type][item.index].score[turn - 1].isSelected = true;\r\n\r\n      // Para indicar que hay un bono de yanzy disponible\r\n      // Pero antes se debe validar que el espacio del yanzy ya haya sido ocupado\r\n      const isYanzySelected =\r\n        copyBoardState.LOWER_SECTION.filter(\r\n          (v) => v.value === \"YATZY\" && v.score[turn - 1].isUsed\r\n        ).length !== 0;\r\n\r\n      // Si se ha ontendo un yatzy y ya se había usado el espacio dle mismo\r\n      // se indica que se tiene un bono de yanzy, en la casilla seleccionada\r\n      copyBoardState[item.type][item.index].score[turn - 1].isBonusYatzy =\r\n        isYanzySelected && isYatzy;\r\n    }\r\n\r\n    changeState = true;\r\n  }\r\n\r\n  return { changeState, copyBoardState, newItemSelected };\r\n};\r\n\r\n/**\r\n * Deselecciona un ítem del board,\r\n * sólo si antes estaba seleccionado\r\n * @param boardState\r\n * @param itemSelected\r\n * @param turn\r\n * @returns\r\n */\r\nexport const deselectBoardItemBoard = (\r\n  boardState: IBoard,\r\n  itemSelected: ItemSelectedBoard,\r\n  turn: TotalPlayers\r\n) => {\r\n  const copyBoardState: IBoard = cloneDeep(boardState);\r\n\r\n  copyBoardState[itemSelected.type][itemSelected.index].score[\r\n    turn - 1\r\n  ].isSelected = false;\r\n\r\n  // Por si se tenía un bono de Yatzy activado\r\n  copyBoardState[itemSelected.type][itemSelected.index].score[\r\n    turn - 1\r\n  ].isBonusYatzy = false;\r\n\r\n  return copyBoardState;\r\n};\r\n\r\n/**\r\n * Una vez presionado el botón de Play, se calcula el score\r\n * @param boardState\r\n * @param itemSelected\r\n * @param players\r\n * @param turn\r\n * @param typeGame\r\n * @param isYatzy\r\n * @returns\r\n */\r\nexport const calculateScore = (\r\n  boardState: IBoard,\r\n  itemSelected: ItemSelectedBoard,\r\n  players: Player[],\r\n  turn: TotalPlayers,\r\n  typeGame: TypeGame,\r\n  isYatzy: boolean\r\n) => {\r\n  const copyBoardState: IBoard = cloneDeep(boardState);\r\n  const copyPlayers: Player[] = cloneDeep(players);\r\n  const { type, index } = itemSelected;\r\n  const { isBonusEarned } = copyPlayers[turn - 1];\r\n  const { temporal } = copyBoardState[type][index].score[turn - 1];\r\n\r\n  // Se valida si es un bono para el yanzy, sólo ocurre si:\r\n  // 1. Si se ha obtenido un Yanzy\r\n  // 2. Si la casilla que se ha seleccionado no es un YATZY\r\n  // 3. Y además que la casilla de YATZY esté ya ocupada\r\n  let isBonusYatzy = false;\r\n  if (isYatzy && copyBoardState[type][index].value !== \"YATZY\") {\r\n    const indexYanzy = copyBoardState.LOWER_SECTION.findIndex(\r\n      (v) => v.value === \"YATZY\"\r\n    );\r\n\r\n    isBonusYatzy =\r\n      copyBoardState.LOWER_SECTION[indexYanzy].score[turn - 1].isUsed;\r\n  }\r\n\r\n  // Se toma el valor temporal de la casilla\r\n  // si había un bono de tipo yatzy se lo agrega\r\n  const finalValue = temporal + (isBonusYatzy ? YATZY_SCORES.YATZY : 0);\r\n  copyBoardState[type][index].score[turn - 1].isSelected = false;\r\n  copyBoardState[type][index].score[turn - 1].isUsed = true;\r\n  copyBoardState[type][index].score[turn - 1].isBonusYatzy = false;\r\n  copyBoardState[type][index].score[turn - 1].value = finalValue;\r\n\r\n  /**\r\n   * Se calcula todo el valor de la sección de nuevo\r\n   * Si ya había ontenido el bono, se añade el valor al existente\r\n   */\r\n  let scoreUpperSection =\r\n    calculateScoreSections(copyBoardState.UPPER_SECTION, turn) +\r\n    (isBonusEarned ? BONUS_VALUE : 0);\r\n\r\n  /**\r\n   * Se valida si el puntaje obtenido es mayor e igual que el valor mínimo para el bono\r\n   * Igualmente se valida que no se haya dado el bono antes\r\n   */\r\n  if (!isBonusEarned && scoreUpperSection >= MIN_SCORE_BONUS) {\r\n    copyPlayers[turn - 1].isBonusEarned = true;\r\n    scoreUpperSection += BONUS_VALUE;\r\n  }\r\n\r\n  const scoreLowerSection = calculateScoreSections(\r\n    copyBoardState.LOWER_SECTION,\r\n    turn\r\n  );\r\n\r\n  copyPlayers[turn - 1].score = scoreUpperSection + scoreLowerSection;\r\n\r\n  copyPlayers[turn - 1].scoreBoard = {\r\n    UPPER_SECTION: scoreUpperSection,\r\n    LOWER_SECTION: scoreLowerSection,\r\n  };\r\n\r\n  const isGameOver = validateGameOver(copyBoardState, typeGame);\r\n\r\n  return {\r\n    copyBoardState,\r\n    copyPlayers,\r\n    isGameOver,\r\n  };\r\n};\r\n\r\n/**\r\n * Función que establece los valores que seleccionará el bot de los dados\r\n * Es aleatorio, sólo se hará cuando ya se haya realizado un lazamiento\r\n * De lo contrario no se selecciona ninguno...\r\n * @param diceValues\r\n * @param throwing\r\n * @returns\r\n */\r\nexport const diceRandomSelectionBot = (\r\n  diceValues: DiceValue[],\r\n  throwing: number\r\n) => {\r\n  const copyDiceValues = cloneDeep(diceValues);\r\n\r\n  // Determinar la cantidad de dados que se van a bloquear/seleccionar...\r\n  // Si es cero, no se bloquea ninguno...\r\n  // Se deja máximo 4, para que no bloquee todos los dados,\r\n  // al menos, uno quedará activo...\r\n  const totalSelectedDice = randomNumber(0, 4);\r\n\r\n  /**x\r\n   * Sólo ingresa si el número de lanzamientos es menor al permitido (3)\r\n   * Además que el valor aletorio haya indicado el número de dados a bloquear...\r\n   */\r\n  if (throwing < TOTAL_THROWING && totalSelectedDice > 0) {\r\n    const diceIndices = getSelectionRandomDice(totalSelectedDice);\r\n\r\n    //Se itera los dados y se habilitan los que estén en el vector de indices...\r\n    // los demás se deseleccionan...\r\n    for (let i = 0; i < copyDiceValues.length; i++) {\r\n      copyDiceValues[i].selected = diceIndices.includes(i);\r\n    }\r\n  }\r\n\r\n  return copyDiceValues;\r\n};\r\n\r\n/**\r\n * Fnción que determina:\r\n * Si habá un nuevo lanzamiento de dado o\r\n * indicará cual es el ítem del board que seleccionará...\r\n * @param boardState\r\n * @param throwing\r\n * @param difficulty\r\n * @param isYatzy\r\n * @param turn\r\n * @returns\r\n */\r\nexport const validateNextBotRoll = (\r\n  boardState: IBoard,\r\n  throwing: number,\r\n  difficulty: Difficulty,\r\n  isYatzy: boolean,\r\n  turn: TotalPlayers\r\n) => {\r\n  /**\r\n   * Se determina la dificultad final del lanzamiento para el bot\r\n   * En este caso si la dificultad es medium, ésta se determina de forma aleatoria\r\n   */\r\n  const finalDifficulty: Difficulty =\r\n    difficulty === EDifficulty.MEDIUM\r\n      ? randomNumber(0, 1) === 1\r\n        ? EDifficulty.HARD\r\n        : EDifficulty.EASY\r\n      : difficulty;\r\n\r\n  /**\r\n   * Se obtien el valor potencial del score para la sección alta\r\n   * En este caso se devuleve sólo un valor, el cual dependiendo de la\r\n   * dificultad podrá ser el mayor de todos o el menor\r\n   */\r\n  const scoreUpperSection = getScoreSectionBot(\r\n    boardState.UPPER_SECTION,\r\n    turn,\r\n    finalDifficulty\r\n  );\r\n\r\n  /**\r\n   * Mismo proceso para la sección baja..\r\n   */\r\n  const scoreLowerSection = getScoreSectionBot(\r\n    boardState.LOWER_SECTION,\r\n    turn,\r\n    finalDifficulty\r\n  );\r\n\r\n  /**\r\n   * Determina si los valores resultantes del board existen,\r\n   * si es así determina si los valores no son cero\r\n   * Si alguno de los dos no es cero, se indica que no es necesario\r\n   * otro lanzamiento...\r\n   */\r\n  let isValueOnBoard = false;\r\n  if (scoreUpperSection || scoreLowerSection) {\r\n    if (scoreUpperSection) {\r\n      isValueOnBoard = scoreUpperSection?.score !== 0;\r\n    }\r\n\r\n    if (!isValueOnBoard && scoreLowerSection) {\r\n      isValueOnBoard = scoreLowerSection?.score !== 0;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Se vuleve a lanzar un dado si:\r\n   * 1. Sí aún se tienen lanzamientos disponibles.\r\n   * 2. Si se determina que entre los valores devueltos a un valor diferente a cero.\r\n   * 3. Si no hay un Yatzy.\r\n   */\r\n  const rollAgain = throwing > 0 && !isValueOnBoard && !isYatzy;\r\n\r\n  // Es el que indica el elemento que se selecciona\r\n  // Es let por que su valor puede que cambie...\r\n  let itemSelected: ItemSelectedBoard = cloneDeep(INITIAL_ITEM_SELECTED);\r\n\r\n  // Si se decide que no se hace otro lanzamiento se va a elegir la casilla\r\n  if (!rollAgain) {\r\n    // Si se ha obtenido un Yanzy, se buscará la casilla de Yanzy\r\n    if (isYatzy) {\r\n      // Se obtiene la casilla del yanzy\r\n      const indexYanzy = boardState.LOWER_SECTION.findIndex(\r\n        (v) => v.value === \"YATZY\"\r\n      );\r\n\r\n      // Se valida que el Yatzy no haya sido seleccionado ya\r\n      if (!boardState.LOWER_SECTION[indexYanzy].score[turn - 1].isUsed) {\r\n        // Como no se ha seleccionado, se toma la casilla\r\n        // y por lo tanto se haría el lanzamiento\r\n        itemSelected.index = indexYanzy;\r\n        itemSelected.type = EItemType.LOWER_SECTION;\r\n      }\r\n    }\r\n\r\n    // Si el valor es menor que 0 para itemSelected,\r\n    // quiere decir que no se ha seleccionado nada\r\n    // Podría estar seleccionado si antes fue un Yanzy\r\n    if (itemSelected.index < 0) {\r\n      /**\r\n       * Se valida que existan score en ambas partes del board\r\n       */\r\n      if (scoreUpperSection && scoreLowerSection) {\r\n        /**\r\n         * Se obtiene el puntaje cuando la dificultad es alta\r\n         * En este caso se toma el mayor valor de las dos secciones\r\n         */\r\n        const scoreDifficultyHard: ItemSelectedBoard =\r\n          scoreUpperSection.score > scoreLowerSection.score\r\n            ? {\r\n                index: scoreUpperSection.index,\r\n                type: EItemType.UPPER_SECTION,\r\n              }\r\n            : {\r\n                index: scoreLowerSection.index,\r\n                type: EItemType.LOWER_SECTION,\r\n              };\r\n\r\n        /**\r\n         * Se obtiene el score cuando la dificultad es baja\r\n         * En este caso se toma el valor menor\r\n         */\r\n        const scoreDifficultyEasy: ItemSelectedBoard =\r\n          scoreUpperSection.score < scoreLowerSection.score\r\n            ? {\r\n                index: scoreUpperSection.index,\r\n                type: EItemType.UPPER_SECTION,\r\n              }\r\n            : {\r\n                index: scoreLowerSection.index,\r\n                type: EItemType.LOWER_SECTION,\r\n              };\r\n\r\n        // Se guardan los scores finales\r\n        const scoresObtained: {\r\n          [key in Exclude<Difficulty, \"MEDIUM\">]: ItemSelectedBoard;\r\n        } = {\r\n          HARD: scoreDifficultyHard,\r\n          EASY: scoreDifficultyEasy,\r\n        };\r\n\r\n        // Dependiendo del nivel, se establece cual es el ítem seleccionado\r\n        itemSelected = scoresObtained[finalDifficulty];\r\n      } else {\r\n        if (scoreUpperSection) {\r\n          itemSelected.index = scoreUpperSection.index;\r\n          itemSelected.type = EItemType.UPPER_SECTION;\r\n        }\r\n\r\n        if (scoreLowerSection) {\r\n          itemSelected.index = scoreLowerSection.index;\r\n          itemSelected.type = EItemType.LOWER_SECTION;\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  return { rollAgain, itemSelected };\r\n};","import React, { useCallback, useEffect, useState } from \"react\";\r\nimport { BoardItem } from \"./components/board/components\";\r\nimport { DiceState, DiceTheme, Difficulty, IBoardItem, ItemSelectedBoard, OnlinePlay, OnlineRollDice, Player, TotalPlayers, TypeButtonGame, type TypeGame, type valueDice } from \"../../interfaces\";\r\nimport {Board, Buttons, Dices, GameMessages, GameWrapper, Header, ScoreGame} from \"./components\";\r\nimport { calculateBoardValues, calculateScore, deselectBoardItemBoard, diceRandomSelectionBot, getInitalBoardState, getInitialDiceValues, getInitialPlayers, rollDice, selectDice, selectItemBoard, totalDiceAvailable, validateNextBotRoll } from './helpers';\r\nimport board from \"./components/board\";\r\nimport { delay } from \"../../utils/helpers\";\r\nimport { playSounds } from \"../../utils/sounds\";\r\nimport { EDiceState, EDiceTheme, EDifficulty, ETypeButtonGame, ETypeGame, INITIAL_ITEM_SELECTED, TOTAL_THROWING } from \"../../utils/constants\";\r\nimport { Socket } from \"socket.io-client\";\r\nimport { useShowMessageRedirect } from \"../../hooks\";\r\n\r\ninterface GameProps {\r\n  authUser: Partial<Player>;\r\n  difficulty?: Difficulty;\r\n  initialTurn: TotalPlayers;\r\n  opponent?: Partial<Player>;\r\n  room?: string;\r\n  socket?: Socket;\r\n  typeGame: TypeGame;\r\n}\r\n\r\nconst Game = ({\r\n  authUser = {},\r\n  difficulty = EDifficulty.EASY,\r\n  initialTurn = 2,\r\n  opponent = {},\r\n  room = \"\",\r\n  socket,\r\n  typeGame = ETypeGame.BOT,\r\n}: GameProps) => {\r\n\r\n    //muestra mensaje y redirecciona el usuario a un path especificado\r\n    const setRedirect = useShowMessageRedirect();\r\n\r\n    //Guarda el estado del boars\r\n    const [boardState, setBoardState] = useState(getInitalBoardState);\r\n\r\n    // Estado de los jugadores (maximo seran dos)\r\n    const [players, setPlayers] = useState(()=> getInitialPlayers(typeGame, authUser, opponent));\r\n\r\n    //Para el turno\r\n    const [turn, setTurn] = useState<TotalPlayers>(typeGame !== ETypeGame.SOLO ? initialTurn: 1);\r\n\r\n    //Estado de los dados\r\n    const [diceValues, setDiceValues] = useState(() => getInitialDiceValues());\r\n\r\n    //Estado de animacion de los dados\r\n    const [dieState, setDieSate] = useState<DiceState>(EDiceState.HIDE);\r\n\r\n     // Guardará el estado del total de lanzamientos \r\n    const [throwing, setThrowing] = useState(TOTAL_THROWING);\r\n\r\n    // Para saber si se ha logrado un Yatzy\r\n    const [isYatzy, setIsYatzy] = useState(false);\r\n\r\n    // Para guardar el ítem seleccionado en el board\r\n    const [itemSelected, setItemSelected] = useState<ItemSelectedBoard>(\r\n        INITIAL_ITEM_SELECTED\r\n    );\r\n    // Estado para saber si el juego ha terminado\r\n    const [gamerOver, setGamerOver] = useState(false);\r\n\r\n    const [message, setMessage] = useState({\r\n        isYatzy: false,\r\n        value: typeGame === ETypeGame.FRIEND ? `Player ${turn}` : \"\",\r\n        counter: typeGame === ETypeGame.FRIEND ? 1 : 0,\r\n    });\r\n\r\n    /**\r\n    * Evento que se ejecuta una vez ha terminado de girar los dados\r\n    */\r\n    const handleDoneDices = () => {\r\n        \r\n        const {copyBoardState, isYatzy: newIsYatzy} = calculateBoardValues(boardState, diceValues, turn);\r\n\r\n        setBoardState(copyBoardState);\r\n        setIsYatzy(newIsYatzy);\r\n\r\n        setDieSate(EDiceState.STOPPED);\r\n        setItemSelected(INITIAL_ITEM_SELECTED);\r\n\r\n        //Mensaje si es yatzy\r\n        if (newIsYatzy) {\r\n            setMessage((prev) => ({\r\n                isYatzy: true,\r\n                value: `Yatzy`,\r\n                counter: prev.counter + 1,\r\n            }));\r\n            playSounds(\"yatzy\");\r\n        }\r\n    };\r\n\r\n    /**\r\n    * Función que establece la selección de un dado\r\n    * @param index\r\n    */\r\n   const handleSelectDice = (index: number) => {\r\n    playSounds(\"click\");\r\n        setDiceValues(selectDice(diceValues, index));\r\n    };\r\n\r\n    /**\r\n    * Evento para los botones de girar los dados\r\n    * y seleccionar el ítem del board\r\n    * @param type\r\n    */\r\n    const handleClickButtons = useCallback((type:TypeButtonGame) => {\r\n        if (type === ETypeButtonGame.ROLL) {\r\n\r\n            // dejar el board sin opciones seleccionadas\r\n            // solo si habia una seleccionada\r\n            if (itemSelected.index >= 0) {\r\n                setBoardState((board) => deselectBoardItemBoard(board, itemSelected, turn));\r\n            }\r\n\r\n            setDiceValues((values) => {\r\n                const newDiceValues = rollDice(values);\r\n\r\n                // Se emite un socket si está en la jugabilidad online\r\n                if (typeGame === ETypeGame.ONLINE) {\r\n                  socket?.emit(\"ACTIONS\", {\r\n                    room,\r\n                    diceValues: newDiceValues,\r\n                    type: ETypeButtonGame.ROLL,\r\n                  } as OnlineRollDice);\r\n                }\r\n\r\n                return newDiceValues;\r\n              });\r\n\r\n\r\n            setDieSate(EDiceState.SPIN);\r\n            setThrowing((value) => value - 1);\r\n        }\r\n\r\n        if (type === ETypeButtonGame.PLAY) {\r\n            const {copyBoardState, copyPlayers, isGameOver} = calculateScore(\r\n                boardState,\r\n                itemSelected,\r\n                players,\r\n                turn,\r\n                typeGame,\r\n                isYatzy\r\n            );\r\n\r\n            setBoardState(copyBoardState);\r\n            setPlayers(copyPlayers);\r\n\r\n            // Reiniciar el estado\r\n            setThrowing(TOTAL_THROWING);\r\n            setDieSate(EDiceState.HIDE);\r\n            setDiceValues(getInitialDiceValues());\r\n            setItemSelected(INITIAL_ITEM_SELECTED);\r\n            setGamerOver(isGameOver);\r\n\r\n            //Sonido cuando hace click en play\r\n            playSounds(\"click\");\r\n\r\n            //Sonido cuando acaba el juego\r\n            if (isGameOver) {\r\n              playSounds(\"yatzy\");\r\n            }\r\n\r\n            // Se emite el valor que se ha seleccionado\r\n            // Sólo aplica si es el turno del jugador uno, que será el actual\r\n            // Además emite isGameOver para eliminar la sala, sólo lo hará un jugador\r\n            if (turn === 1 && typeGame === ETypeGame.ONLINE) {\r\n              socket?.emit(\"ACTIONS\", {\r\n                room,\r\n                itemSelected,\r\n                isGameOver,\r\n                type: ETypeButtonGame.PLAY,\r\n              } as OnlinePlay);\r\n            }\r\n\r\n            if (!isGameOver && typeGame !== ETypeGame.SOLO) {\r\n                const newTurn: TotalPlayers = turn === 1 ? 2 : 1;\r\n                setTurn(newTurn);\r\n\r\n                //Al cambiar de turno y es vs friend\r\n                //en el mismo dispositivo, se muestra el mensaje\r\n                if (typeGame === ETypeGame.FRIEND) {\r\n                    setMessage((prev) => ({\r\n                        isYatzy: false,\r\n                        value: `Player ${newTurn}`,\r\n                        counter: prev.counter + 1,\r\n                    }));\r\n                }\r\n            }\r\n        }\r\n    }, [boardState, isYatzy, itemSelected, players, room, socket, turn, typeGame]);\r\n\r\n    /**\r\n   * Evento para la selección de un elemento en el board\r\n   * @param item\r\n   * @param player\r\n   */\r\n  const handleClickBoard = (item: IBoardItem, player: TotalPlayers) => {\r\n    const { changeState, copyBoardState, newItemSelected } = selectItemBoard(\r\n      boardState,\r\n      itemSelected,\r\n      item,\r\n      player,\r\n      isYatzy\r\n    );\r\n\r\n    if (changeState) {\r\n      playSounds(\"click\");\r\n      setBoardState(copyBoardState);\r\n      setItemSelected(newItemSelected);\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Efecto que se ejecuta cuando giran los dados.\r\n   * Sólo para el bot\r\n   */\r\n  useEffect(() => {\r\n    const isBotTurn = typeGame === ETypeGame.BOT && turn === 2;\r\n\r\n    const runAsyncRollDice = async () => {\r\n      // Realiza la acción 1 segundo depsupés\r\n      // Para que no se ejecute de inmediato al cargar el componente\r\n      await delay(1000);\r\n      /**\r\n       * Se simula el lanzamiento del dado\r\n       * la función diceRandomSelectionBot, simula selecciones del dado,\r\n       * no lo hará para el primer lanzamiento\r\n       */\r\n      setDiceValues((value) =>\r\n        rollDice(diceRandomSelectionBot(value, throwing))\r\n      );\r\n      setDieSate(EDiceState.SPIN);\r\n      setThrowing((value) => value - 1);\r\n    };\r\n\r\n    // El turno inicial para el bot\r\n    // Además se valida que el juego no haya terminado aún\r\n    if (!gamerOver && isBotTurn && dieState === EDiceState.HIDE) {\r\n      runAsyncRollDice();\r\n    }\r\n\r\n    if (isBotTurn && dieState === EDiceState.STOPPED) {\r\n      const { rollAgain = false, itemSelected: newItemSelected } =\r\n        validateNextBotRoll(boardState, throwing, difficulty, isYatzy, turn);\r\n\r\n      if (rollAgain) {\r\n        runAsyncRollDice();\r\n      } else {\r\n        setItemSelected(newItemSelected);\r\n      }\r\n    }\r\n\r\n    if (!gamerOver && dieState === EDiceState.SPIN) {\r\n      playSounds(\"dice\");\r\n    }\r\n  }, [\r\n    boardState,\r\n    dieState,\r\n    difficulty,\r\n    gamerOver,\r\n    isYatzy,\r\n    throwing,\r\n    turn,\r\n    typeGame,\r\n  ]);\r\n\r\n   /**\r\n   * Efecto que se ejcuta cuando se ha seleccionado un ítem del board\r\n   * ES aplicable para el bot y para el oponente en la jugabilidad online\r\n   */\r\n   useEffect(() => {\r\n    const isBotTurn = typeGame === ETypeGame.BOT && turn === 2;\r\n    const isOponentTurn = typeGame === ETypeGame.ONLINE && turn === 2;\r\n\r\n    const runAsyncPlayBot = async () => {\r\n      await delay(2000);\r\n      handleClickButtons(ETypeButtonGame.PLAY);\r\n    };\r\n\r\n    if ((isBotTurn || isOponentTurn) && itemSelected.index >= 0) {\r\n      if (isBotTurn) {\r\n        runAsyncPlayBot();\r\n      } else {\r\n        handleClickButtons(ETypeButtonGame.PLAY);\r\n      }\r\n    }\r\n  }, [handleClickButtons, itemSelected, turn, typeGame]);\r\n\r\n\r\n  /**\r\n   * Eefecto que ejecuta las acciones online del juego...\r\n   */\r\n  useEffect(() => {\r\n    if (socket) {\r\n      /**\r\n       * El oponente se ha desconectado...\r\n       */\r\n      socket.on(\"OPPONENT_LEAVE\", () => {\r\n        setRedirect({\r\n          message: {\r\n            title: \"Oponente desconectado 😭\",\r\n            icon: \"error\",\r\n            timer: 5000,\r\n          },\r\n        });\r\n      });\r\n\r\n      /**\r\n       * Evento que se ejecuta cuando el oponente ha girando los dados\r\n       */\r\n      socket.on(ETypeButtonGame.ROLL, (data: OnlineRollDice) => {\r\n        // Sólo es aplicable para el oponente no para el usuario actual\r\n        // Establece el valor de los dados que llega\r\n        setDiceValues(data.diceValues);\r\n        setDieSate(EDiceState.SPIN);\r\n        setThrowing((value) => value - 1);\r\n      });\r\n\r\n      /**\r\n       * Evento que se ejecuta cuando se ha seleccionado un valor del board...\r\n       */\r\n      socket.on(ETypeButtonGame.PLAY, (data: OnlinePlay) => {\r\n        // Sólo es aplicable para el oponente no para el usuario actual\r\n        setItemSelected(data.itemSelected);\r\n      });\r\n    }\r\n  }, [setRedirect, socket]);\r\n\r\n\r\n    /**\r\n    * Función que retorna cuando el contador de tiempo ha finalizado\r\n    * Sólo se ejecutará el tipo Online\r\n    * @param player\r\n    */\r\n    const onEndCountdown = (player: TotalPlayers) => {\r\n      if (player === 1) {\r\n        setRedirect({\r\n          message: {\r\n            title: \"Se acabo el tiempo!\",\r\n            icon: \"info\",\r\n            timer: 5000,\r\n          },\r\n        });\r\n      }\r\n    };\r\n\r\n    /**\r\n     * Solo se agrega el cronometro cuando es online\r\n     */\r\n    const countdown = \r\n    typeGame === ETypeGame.ONLINE \r\n    ? {stop: dieState === EDiceState.SPIN && !gamerOver, onEndCountdown}\r\n    : undefined;\r\n\r\n    // Para saber si es el caso donde la interfaz de ambos lados\r\n    // se habilita para cuando hay dos jugadores, en este caso, sólo\r\n    // aplica cuando se está jugando con un amigo\r\n    const turnsEnabledTwoPlayers = turn === 1 || typeGame === ETypeGame.FRIEND;\r\n\r\n    /**\r\n    * Se bloquea el contenido para el jugador uno\r\n    * útil cuando se juega contra un BOT o ONLINE\r\n    * Se aplica siempre y cuando no sea game over\r\n    * y además que sea el turno dos\r\n    */\r\n    const blockContent =\r\n    !gamerOver && (typeGame === ETypeGame.BOT || typeGame === ETypeGame.ONLINE) && turn === 2;\r\n\r\n    /**\r\n    * Bloquea el botón que lanza los dados\r\n    */\r\n    const disabledRoll = \r\n    blockContent || \r\n    gamerOver ||\r\n    dieState === EDiceState.SPIN || \r\n    throwing <= 0 ||\r\n    totalDiceAvailable(diceValues) === 0;\r\n\r\n    /**\r\n    * Bloquear el botón que acepta la selección de un ítem\r\n    */\r\n    const disabledPlay =\r\n    blockContent || \r\n    dieState === EDiceState.SPIN ||\r\n    itemSelected.index < 0;\r\n\r\n    /**\r\n    * Sólo muestra el botón de play si:\r\n    * No se ha acabdo el juego\r\n    * Si los dados están visibles\r\n    * Además que sea el turno 1 o que sea de tipo jugar con amigo\r\n    */\r\n    const showPlay = !gamerOver && dieState !== EDiceState.HIDE && turnsEnabledTwoPlayers;\r\n\r\n    /**\r\n   * Sólo será blanco para dos juagdores si s esta jugando con un amigo\r\n   * De lo contrario, cuando tiene el turno el jugador dos, de los otros tipos\r\n   * el color cambiará a rojo\r\n   */\r\n  const diceTheme: DiceTheme = EDiceTheme[turnsEnabledTwoPlayers ? \"WHITE\" : \"RED\"];\r\n\r\n\r\n\r\n  // Para validar si se muestra los valores de la tabla...\r\n  // Cuando es el turno del jugador dos, salvo que se este jugando con un amigo\r\n  // no se mostrará estos valores\r\n  const thrownDice = turnsEnabledTwoPlayers && dieState === EDiceState.STOPPED;\r\n\r\n    return (\r\n        <GameWrapper blockContent={blockContent}>\r\n            {gamerOver && <ScoreGame players={players}/>}\r\n            <GameMessages {...message}/>\r\n            <Header countdown={countdown} players={players} turn={turn}/>\r\n            <Board\r\n                items={boardState}\r\n                players={players}  \r\n                thrownDice={thrownDice}\r\n                turn={turn}\r\n                typeGame={typeGame}\r\n                handleClick={handleClickBoard} \r\n            />\r\n            <Dices \r\n            dieState={dieState} \r\n            values={diceValues} \r\n            diceTheme={diceTheme}\r\n            handleDoneDices={handleDoneDices}\r\n            handleSelectedDice={handleSelectDice}\r\n            />\r\n            <Buttons\r\n            disabledPlay={disabledPlay}\r\n            disabledRoll={disabledRoll}\r\n            showPlay={showPlay}\r\n            throwing={throwing}\r\n             handleClick={handleClickButtons}/>\r\n        </GameWrapper>\r\n    );\r\n};\r\n\r\nexport default React.memo(Game);"],"names":["Board","props","_jsxs","BoardWrapper","children","_jsx","BoardHeader","typeGame","BoardTable","React","GameWrapper","_ref","blockContent","className","HeaderWrapper","PlayersHeader","countdown","players","turn","map","player","index","ScoreHeader","isSelected","id","name","score","ScoreCounter","concat","Countdown","stopCounter","stop","handleEndCountdown","onEndCountdown","initialValue","INTERVAL_VALUE_COUNTDOWN","intervalTime","INTERVAL_TIME","count","setCount","useState","isRunning","setIsRunning","useEffect","useInterval","newCount","Header","withSound","toggleSound","useSounds","navigate","useNavigate","CircularButton","type","onClick","cb","action","swal","title","text","icon","closeOnClickOutside","closeOnEsc","buttons","then","value","DiceWrapper","theme","WHITE","dotColor","faceColor","RED","DiceButton","dice","selected","dieState","EDiceState","HIDE","diceTheme","EDiceTheme","handleDone","handleSelectedDice","refDice","useRef","rollTime","SPIN","STOPPED","disabledButton","_refDice$current","current","rollAll","disabled","ReactDice","dieSize","disableIndividual","numDice","outlineColor","ref","rollDone","counterRollingDice","Dices","values","handleDoneDices","handleAllDiceComplete","includes","push","totalStopDice","filter","v","length","Buttons","disabledPlay","disabledRoll","showPlay","throwing","TOTAL_THROWING","handleClick","ETypeButtonGame","ROLL","LABELS_GAME","PLAY","ScoreValue","handleShowScore","handleEndTimer","ScoreGame","scoreCounter","setScoreCounter","showElements","setShowElements","scoreMessage","AMAZING_SCORE","TIE","WON","LOSE","dataShare","url","window","location","origin","FocusTrap","_ref2","key","Icon","fill","Share","data","GameMessages","isYatzy","counter","showMessage","setShowMessage","interval","setTimeout","clearTimeout","totalDiceSameValue","diceValues","calculateSumDiceSameValue","calculateDiceSameType","repetitions","arguments","undefined","exactValue","isRepetition","i","total","calculateIsStraight","straight","isStraight","copyDiceValues","Set","cloneDeep","sort","a","b","initial","counterStraight","calculateScoreSections","section","reduce","s","getScoreSectionBot","difficulty","scores","isUsed","temporal","EDifficulty","HARD","scoreNoZero","scoreZero","getInitalBoardState","initialScore","isBonusYatzy","UPPER_SECTION","Array","_","label","UPPER_SECTION_LABELS","EItemType","LOWER_SECTION","CATEGORIES","category","LOWER_SECTION_LABELS","getInitialDiceValues","rollDice","randomNumber","calculateScore","boardState","itemSelected","copyBoardState","copyPlayers","isBonusEarned","indexYanzy","findIndex","finalValue","YATZY_SCORES","YATZY","scoreUpperSection","BONUS_VALUE","MIN_SCORE_BONUS","scoreLowerSection","scoreBoard","isGameOver","validateGameOver","scoreSize","ETypeGame","SOLO","Object","keys","size","totalSize","c","every","diceRandomSelectionBot","totalSelectedDice","diceIndices","selectedDice","randomDice","getSelectionRandomDice","Game","authUser","EASY","initialTurn","opponent","room","socket","BOT","setRedirect","useShowMessageRedirect","setBoardState","setPlayers","totalPlayers","basePlayer","YOU","ONLINE","getInitialPlayers","setTurn","setDiceValues","setDieSate","setThrowing","setIsYatzy","setItemSelected","INITIAL_ITEM_SELECTED","gamerOver","setGamerOver","message","setMessage","FRIEND","handleClickButtons","useCallback","board","deselectBoardItemBoard","newDiceValues","emit","playSounds","newTurn","prev","isBotTurn","runAsyncRollDice","async","delay","rollAgain","newItemSelected","validateNextBotRoll","finalDifficulty","MEDIUM","isValueOnBoard","isOponentTurn","runAsyncPlayBot","on","timer","turnsEnabledTwoPlayers","totalDiceAvailable","thrownDice","items","handleClickBoard","item","changeState","isYanzySelected","selectItemBoard","newIsYatzy","JSON","parse","stringify","sumAllDice","calculateSumAllDice","isThreeKind","isFourKind","isFullHouse","isSmallStraight","isLargeStraight","lowerSectionValues","THREE_KIND","FOUR_KIND","FULL_HOUSE","FULLHOUSE","SMALL_STRAIGHT","LARGE_STRAIGHT","CHANCE","_copyBoardState$UPPER","totalValue","_copyBoardState$LOWER","calculateBoardValues","diceIndex","selectDice"],"sourceRoot":""}